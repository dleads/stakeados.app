// SSR-safe Supabase selector: use server client on server, browser client on client
function getSupabase() {
  if (typeof window === 'undefined') {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { createClient } = require('@/lib/supabase/server');
    return createClient();
  }
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const { createClient } = require('@/lib/supabase/client');
  return createClient();
}
import { AIContentService } from './aiContentService';
import type { ProcessedNewsArticle } from '@/types/news';
import type { Locale } from '@/types/content';

export class NewsProcessingService {
  private get supabase() {
    return getSupabase();
  }
  private aiService = new AIContentService();

  // Process raw articles with AI and store as processed news articles
  async processRawArticles(limit: number = 50): Promise<{
    processed: number;
    published: number;
    errors: Array<{ id: string; error: string }>;
  }> {
    try {
      // Get unprocessed raw articles
      const { data: rawArticles, error } = await this.supabase.rpc(
        'get_unprocessed_articles' as any,
        { limit_count: limit }
      );

      if (error) {
        throw new Error(`Failed to get unprocessed articles: ${error.message}`);
      }

      if (!rawArticles || rawArticles.length === 0) {
        return { processed: 0, published: 0, errors: [] };
      }

      const results = {
        processed: 0,
        published: 0,
        errors: [] as Array<{ id: string; error: string }>,
      };

      // Process articles in batches
      const batchSize = 10;
      for (let i = 0; i < rawArticles.length; i += batchSize) {
        const batch = rawArticles.slice(i, i + batchSize);

        const batchPromises = batch.map(async (rawArticle: any) => {
          try {
            const processedArticle = await this.processRawArticle(rawArticle);

            if (processedArticle) {
              // Store processed article
              await this.storeProcessedArticle(processedArticle);
              results.processed++;

              // If relevance score is high enough, publish it
              if (
                processedArticle.relevance_score &&
                processedArticle.relevance_score >= 6
              ) {
                results.published++;
              }
            }

            // Mark raw article as processed
            await this.supabase
              .from('raw_news_articles' as any)
              .update({
                is_processed: true,
                processed_at: new Date().toISOString(),
              })
              .eq('id', rawArticle.id);
          } catch (error) {
            console.error(`Failed to process article ${rawArticle.id}:`, error);
            results.errors.push({
              id: rawArticle.id,
              error: error instanceof Error ? error.message : 'Unknown error',
            });
          }
        });

        await Promise.all(batchPromises);

        // Add delay between batches to respect rate limits
        if (i + batchSize < rawArticles.length) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }

      return results;
    } catch (error) {
      console.error('Failed to process raw articles:', error);
      throw error;
    }
  }

  // Process a single raw article with AI
  private async processRawArticle(
    rawArticle: any
  ): Promise<ProcessedNewsArticle | null> {
    try {
      // Determine source locale (default to English)
      const sourceLocale: Locale = rawArticle.source_categories?.includes(
        'Spanish'
      )
        ? 'es'
        : 'en';

      // Process with AI
      const aiResult = await this.aiService.processNewsArticle(
        rawArticle.title,
        rawArticle.content,
        rawArticle.url,
        rawArticle.source_name,
        sourceLocale
      );

      // Skip articles with very low relevance
      if (aiResult.relevanceScore < 3) {
        console.log(
          `Skipping article ${rawArticle.id} due to low relevance score: ${aiResult.relevanceScore}`
        );
        return null;
      }

      // Create processed article
      const processedArticle: ProcessedNewsArticle = {
        id: '', // Will be generated by database
        title:
          sourceLocale === 'en'
            ? {
                en: rawArticle.title,
                es: aiResult.translatedContent
                  ? this.extractTitleFromContent(aiResult.translatedContent.es)
                  : rawArticle.title,
              }
            : {
                es: rawArticle.title,
                en: aiResult.translatedContent
                  ? this.extractTitleFromContent(aiResult.translatedContent.en)
                  : rawArticle.title,
              },
        summary: aiResult.summary,
        content: aiResult.translatedContent || {
          [sourceLocale]: rawArticle.content,
        },
        source_url: rawArticle.url,
        source_name: rawArticle.source_name,
        author_name: rawArticle.author,
        image_url: rawArticle.image_url,
        categories: aiResult.categories,
        keywords: aiResult.keywords,
        relevance_score: aiResult.relevanceScore,
        trending_score: this.calculateTrendingScore(
          aiResult.relevanceScore,
          rawArticle.published_at
        ),
        engagement_score: 0, // Will be updated based on user interactions
        read_time: this.estimateReadTime(rawArticle.content),
        related_articles: [],
        user_interactions: {},
        ai_processed_at: new Date(),
        published_at: new Date(rawArticle.published_at),
        created_at: new Date(),
        updated_at: new Date(),
      };

      return processedArticle;
    } catch (error) {
      console.error(`Failed to process raw article ${rawArticle.id}:`, error);
      throw error;
    }
  }

  // Store processed article in the database
  private async storeProcessedArticle(
    article: ProcessedNewsArticle
  ): Promise<void> {
    try {
      // Insert into news_articles table
      const { data: insertedArticle, error: insertError } = await this.supabase
        .from('news_articles' as any)
        .insert({
          title: article.title,
          summary: article.summary,
          content: article.content,
          source_url: article.source_url,
          source_name: article.source_name,
          author_name: article.author_name,
          image_url: article.image_url,
          categories: article.categories,
          keywords: article.keywords,
          relevance_score: article.relevance_score,
          trending_score: article.trending_score,
          engagement_score: article.engagement_score,
          read_time: article.read_time,
          related_articles: article.related_articles,
          user_interactions: article.user_interactions,
          ai_processed_at: article.ai_processed_at?.toISOString(),
          published_at: article.published_at.toISOString(),
        })
        .select('id')
        .single();

      if (insertError) {
        throw new Error(
          `Failed to insert processed article: ${insertError.message}`
        );
      }

      // Add categories to junction table
      if (article.categories.length > 0 && insertedArticle) {
        await this.addArticleCategories(
          (insertedArticle as any).id,
          article.categories
        );
      }
    } catch (error) {
      console.error('Failed to store processed article:', error);
      throw error;
    }
  }

  // Add article categories to junction table
  private async addArticleCategories(
    articleId: string,
    categoryNames: string[]
  ): Promise<void> {
    try {
      // Get category IDs
      const { data: categories, error: categoryError } = await this.supabase
        .from('content_categories' as any)
        .select('id, name')
        .in('name->en', categoryNames);

      if (categoryError) {
        console.error('Failed to get categories:', categoryError);
        return;
      }

      if (categories && categories.length > 0) {
        const categoryMappings = categories.map((category: any) => ({
          news_id: articleId,
          category_id: category.id,
        }));

        const { error: mappingError } = await this.supabase
          .from('news_categories' as any)
          .insert(categoryMappings);

        if (mappingError) {
          console.error('Failed to add category mappings:', mappingError);
        }
      }
    } catch (error) {
      console.error('Failed to add article categories:', error);
    }
  }

  // Extract title from translated content (fallback method)
  private extractTitleFromContent(content: string): string {
    // Try to extract the first line or sentence as title
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    if (lines.length > 0) {
      const firstLine = lines[0].trim();
      // If first line looks like a title (not too long, no periods in middle)
      if (firstLine.length < 150 && !firstLine.includes('. ')) {
        return firstLine;
      }
    }

    // Fallback: take first sentence
    const sentences = content.split('. ');
    return (
      sentences[0].substring(0, 100) + (sentences[0].length > 100 ? '...' : '')
    );
  }

  // Calculate trending score based on relevance and recency
  private calculateTrendingScore(
    relevanceScore: number,
    publishedAt: string
  ): number {
    const now = new Date();
    const published = new Date(publishedAt);
    const hoursOld = (now.getTime() - published.getTime()) / (1000 * 60 * 60);

    // Trending score decreases with age
    let recencyMultiplier = 1;
    if (hoursOld < 1)
      recencyMultiplier = 1.5; // Very recent
    else if (hoursOld < 6)
      recencyMultiplier = 1.2; // Recent
    else if (hoursOld < 24)
      recencyMultiplier = 1.0; // Today
    else if (hoursOld < 72)
      recencyMultiplier = 0.8; // Last 3 days
    else recencyMultiplier = 0.5; // Older

    return Math.min(10, relevanceScore * recencyMultiplier);
  }

  // Estimate reading time in minutes
  private estimateReadTime(content: string): number {
    const wordsPerMinute = 200;
    const wordCount = content.split(/\s+/).length;
    return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
  }

  // Find and update related articles
  async updateRelatedArticles(
    articleId: string,
    keywords: string[],
    categories: string[]
  ): Promise<void> {
    try {
      // Find articles with similar keywords or categories
      const { data: similarArticles, error } = await this.supabase
        .from('news_articles' as any)
        .select('id, keywords, categories')
        .neq('id', articleId)
        .limit(20);

      if (error || !similarArticles) return;

      const relatedArticles: string[] = [];

      for (const article of similarArticles) {
        let similarity = 0;
        const articleData = article as any;

        // Check keyword overlap
        const commonKeywords = keywords.filter(keyword =>
          articleData.keywords?.includes(keyword)
        );
        similarity += commonKeywords.length * 2;

        // Check category overlap
        const commonCategories = categories.filter(category =>
          articleData.categories?.includes(category)
        );
        similarity += commonCategories.length * 3;

        // If similarity is high enough, consider it related
        if (similarity >= 3) {
          relatedArticles.push(articleData.id);
        }
      }

      // Update the article with related articles (limit to top 5)
      if (relatedArticles.length > 0) {
        await this.supabase
          .from('news_articles' as any)
          .update({
            related_articles: relatedArticles.slice(0, 5),
          })
          .eq('id', articleId);
      }
    } catch (error) {
      console.error('Failed to update related articles:', error);
    }
  }

  // Get processing statistics
  async getProcessingStats(): Promise<{
    totalRawArticles: number;
    processedArticles: number;
    publishedArticles: number;
    averageRelevanceScore: number;
    processingRate: number;
  }> {
    try {
      const [rawStats, processedStats] = await Promise.all([
        this.supabase
          .from('raw_news_articles' as any)
          .select('is_processed, quality_score')
          .gte(
            'created_at',
            new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
          ),

        this.supabase
          .from('news_articles' as any)
          .select('relevance_score')
          .gte(
            'created_at',
            new Date(Date.now() - 60 * 60 * 1000).toISOString()
          ),
      ]);

      const totalRaw = rawStats.data?.length || 0;
      const processed =
        rawStats.data?.filter((a: any) => a.is_processed).length || 0;
      const published = processedStats.data?.length || 0;
      const avgRelevance = processedStats.data?.length
        ? processedStats.data.reduce(
            (sum, a: any) => sum + (a.relevance_score || 0),
            0
          ) / processedStats.data.length
        : 0;

      return {
        totalRawArticles: totalRaw,
        processedArticles: processed,
        publishedArticles: published,
        averageRelevanceScore: Math.round(avgRelevance * 100) / 100,
        processingRate:
          totalRaw > 0 ? Math.round((processed / totalRaw) * 100) : 0,
      };
    } catch (error) {
      console.error('Failed to get processing stats:', error);
      return {
        totalRawArticles: 0,
        processedArticles: 0,
        publishedArticles: 0,
        averageRelevanceScore: 0,
        processingRate: 0,
      };
    }
  }
}

export const newsProcessingService = new NewsProcessingService();
